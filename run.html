<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>方块跑酷 · 实体碰撞版</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body{
    margin:0;
    background:#2c3e50;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    font-family:Arial;
}
#game{
    width:800px;
    height:400px;
    border:2px solid #ecf0f1;
    background:#34495e;
    position:relative;
}
canvas{background:#1a1a2e}
#ui{
    position:absolute;
    top:8px;
    left:10px;
    color:white;
    font-size:18px;
}
</style>
</head>

<body>
<div id="game">
<canvas id="c" width="800" height="400"></canvas>
<div id="ui"></div>
</div>

<script>
const c=document.getElementById("c");
const ctx=c.getContext("2d");
const ui=document.getElementById("ui");
const keys={};

document.onkeydown=e=>keys[e.key]=true;
document.onkeyup=e=>keys[e.key]=false;

let level=1,camera=0,length=1200;

const player={
    x:100,y:300,w:30,h:30,
    vx:0,vy:0,
    speed:5,jump:-15,
    onGround:false
};

let platforms=[],moving=[],gravity=[],invisible=[],fake=[];

/* ========= 实体碰撞 ========= */
function resolveCollision(a,b){
    const dx=(a.x+a.w/2)-(b.x+b.w/2);
    const dy=(a.y+a.h/2)-(b.y+b.h/2);
    const ox=(a.w+b.w)/2-Math.abs(dx);
    const oy=(a.h+b.h)/2-Math.abs(dy);

    if(ox>0&&oy>0){
        if(ox<oy){
            if(dx>0) a.x+=ox;
            else a.x-=ox;
            a.vx=0;
        }else{
            if(dy>0){
                a.y+=oy;
                a.vy=0;
            }else{
                a.y-=oy;
                a.vy=0;
                a.onGround=true;
            }
        }
    }
}

/* ========= 生成关卡 ========= */
function genLevel(n){
    platforms=[];moving=[];gravity=[];invisible=[];fake=[];
    camera=0;

    const chapter=Math.floor((n-1)/5)+1;
    const isBoss=n%5===0;
    length=isBoss?2200:1200+chapter*250;

    platforms.push({x:0,y:350,w:200,h:50});
    platforms.push({x:length-200,y:350,w:200,h:50});

    let x=250;
    while(x<length-300){
        platforms.push({
            x,
            y:260+Math.sin(x*0.015)*60,
            w:80+Math.random()*40,
            h:20
        });
        x+=180+Math.random()*80;
    }

    if(chapter>=2){
        for(let i=0;i<2+chapter;i++){
            let px=400+Math.random()*(length-800);
            moving.push({
                x:px,y:200,
                sx:px,d:100+chapter*20,
                t:Math.random(),
                sp:0.015+chapter*0.003,
                w:80,h:20
            });
        }
    }

    if(chapter>=3){
        for(let i=0;i<chapter;i++){
            invisible.push({
                x:500+i*300,
                y:180,
                w:100,h:20
            });
        }
    }

    if(chapter>=4){
        for(let i=0;i<chapter;i++){
            fake.push({
                x:450+Math.random()*(length-900),
                y:220+Math.random()*80,
                w:80,h:20
            });
        }
    }

    if(chapter>=5){
        for(let i=0;i<2;i++){
            gravity.push({
                x:600+i*500,
                y:100,
                w:200,h:200,
                g:i%2?1.4:0.5
            });
        }
    }

    ui.innerText=`关卡 ${level}${isBoss?" · BOSS":""}`;
}

function reset(){
    player.x=100;player.y=300;
    player.vx=0;player.vy=0;
    genLevel(level);
}

/* ========= 游戏循环 ========= */
function update(){
    let g=0.8;
    gravity.forEach(z=>{
        if(hit(player,z)) g=z.g;
    });

    player.vx=0;
    if(keys.ArrowLeft)player.vx=-player.speed;
    if(keys.ArrowRight)player.vx=player.speed;

    if((keys.ArrowUp||keys[" "])&&player.onGround){
        player.vy=player.jump;
        player.onGround=false;
    }

    player.vy+=g;
    player.x+=player.vx;
    player.y+=player.vy;
    player.onGround=false;

    [...platforms,...moving,...invisible].forEach(p=>{
        resolveCollision(player,p);
    });

    moving.forEach(p=>{
        p.t+=p.sp;
        p.x=p.sx+Math.sin(p.t)*p.d;
    });

    if(player.y>c.height) reset();
    if(player.x>length){ level++; reset(); }
    if(player.x>c.width/2) camera=player.x-c.width/2;
}

function hit(a,b){
    return a.x<b.x+b.w&&a.x+a.w>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y;
}

function render(){
    ctx.clearRect(0,0,800,400);

    platforms.forEach(p=>{
        ctx.fillStyle="#2ecc71";
        ctx.fillRect(p.x-camera,p.y,p.w,p.h);
    });

    moving.forEach(p=>{
        ctx.fillStyle="#e67e22";
        ctx.fillRect(p.x-camera,p.y,p.w,p.h);
    });

    fake.forEach(p=>{
        ctx.strokeStyle="#95a5a6";
        ctx.strokeRect(p.x-camera,p.y,p.w,p.h);
    });

    gravity.forEach(z=>{
        ctx.fillStyle="rgba(155,89,182,0.35)";
        ctx.fillRect(z.x-camera,z.y,z.w,z.h);
    });

    // 隐形平台不绘制

    ctx.fillStyle="#e74c3c";
    ctx.fillRect(player.x-camera,player.y,player.w,player.h);
}

function loop(){update();render();requestAnimationFrame(loop);}
reset();loop();
</script>
</body>
</html>
