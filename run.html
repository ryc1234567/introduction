<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>方块跑酷 · 自动防无解版</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
body{
    margin:0;background:#2c3e50;
    display:flex;justify-content:center;align-items:center;
    height:100vh;font-family:Arial;
    touch-action:none;
}
#game{
    width:800px;height:400px;
    position:relative;border:2px solid #ecf0f1
}
canvas{background:#1a1a2e}
#ui{position:absolute;top:5px;left:10px;color:white}
#controls{
    position:absolute;bottom:10px;left:0;width:100%;
    display:flex;justify-content:space-between;
    padding:0 20px;box-sizing:border-box;
}
.ctrl-group{display:flex;gap:10px}
.btn{
    width:60px;height:60px;
    background:rgba(255,255,255,0.15);
    border:2px solid rgba(255,255,255,0.5);
    border-radius:12px;
    display:flex;align-items:center;justify-content:center;
    color:white;font-size:26px;
}
.fake{
    opacity:0.35;
}
</style>
</head>

<body>
<div id="game">
<canvas id="c" width="800" height="400"></canvas>
<div id="ui"></div>

<div id="controls">
    <div class="ctrl-group">
        <div class="btn" data-key="ArrowLeft">◀</div>
        <div class="btn" data-key="ArrowRight">▶</div>
    </div>
    <div class="ctrl-group">
        <div class="btn" data-key=" ">⤒</div>
    </div>
</div>
</div>

<script>
const c=document.getElementById("c");
const ctx=c.getContext("2d");
const ui=document.getElementById("ui");
const keys={};

/* 键盘 & 触控 */
document.addEventListener("keydown",e=>keys[e.key]=true);
document.addEventListener("keyup",e=>keys[e.key]=false);
document.querySelectorAll(".btn").forEach(b=>{
    const k=b.dataset.key;
    const p=()=>keys[k]=true;
    const r=()=>keys[k]=false;
    b.ontouchstart=e=>{e.preventDefault();p()};
    b.ontouchend=e=>{e.preventDefault();r()};
    b.onmousedown=p;b.onmouseup=r;b.onmouseleave=r;
});

/* 玩家 */
const player={x:100,y:300,w:30,h:30,vx:0,vy:0,speed:5,jump:-15,onGround:false};

/* 参数（用于检测） */
const MAX_JUMP_X = 220;   // 最大水平跳距
const MAX_JUMP_Y = 120;   // 最大可上跳高度

let level=1,camera=0;
let platforms=[],moving=[],fake=[],blink=[];
let finishPlatform=null;
let finishLineX=0,finished=false;

/* 碰撞 */
function resolve(a,b){
    const dx=(a.x+a.w/2)-(b.x+b.w/2);
    const dy=(a.y+a.h/2)-(b.y+b.h/2);
    const ox=(a.w+b.w)/2-Math.abs(dx);
    const oy=(a.h+b.h)/2-Math.abs(dy);
    if(ox>0&&oy>0){
        if(ox<oy){a.x+=dx>0?ox:-ox;a.vx=0;}
        else{a.y+=dy>0?oy:-oy;a.vy=0;if(dy<0)a.onGround=true;}
    }
}

/* ===== 可达性检测 ===== */
function isReachable(){
    const nodes = platforms.concat([finishPlatform]);
    const visited = new Set();
    const stack = [platforms[0]];

    while(stack.length){
        const cur = stack.pop();
        if(cur === finishPlatform) return true;
        visited.add(cur);

        for(const next of nodes){
            if(visited.has(next) || next===cur) continue;

            const dx = (next.x) - (cur.x + cur.w);
            const dy = cur.y - next.y;

            if(dx <= MAX_JUMP_X && dx >= -50 && dy <= MAX_JUMP_Y){
                stack.push(next);
            }
        }
    }
    return false;
}

/* ===== 关卡生成 ===== */
function gen(){
    let tries=0;
    do{
        platforms=[];moving=[];fake=[];blink=[];
        finished=false;camera=0;

        platforms.push({x:0,y:350,w:200,h:50});

        let x=260;

        if(level===1){
            for(let i=0;i<6;i++){
                platforms.push({x,y:260+Math.sin(i)*40,w:100,h:20});
                x+=150;
            }
        }

        if(level===2){
            platforms.push({x,y:260,w:100,h:20}); x+=150;
            fake.push({x,y:260,w:90,h:20}); x+=120;
            platforms.push({x,y:240,w:100,h:20}); x+=160;
            fake.push({x,y:260,w:90,h:20}); x+=120;
            platforms.push({x,y:260,w:100,h:20}); x+=160;
        }

        if(level===3){
            for(let i=0;i<6;i++){
                moving.push({x,y:220,sx:x,d:60,t:0,sp:0.03,w:60,h:20});
                platforms.push(moving[moving.length-1]);
                x+=160;
            }
        }

        if(level===4){
            for(let i=0;i<6;i++){
                blink.push({x,y:230,w:80,h:20,t:i*30});
                platforms.push(blink[blink.length-1]);
                x+=150;
            }
        }

        finishPlatform={x:x+80,y:350,w:200,h:50,finish:true};
        platforms.push(finishPlatform);
        finishLineX=finishPlatform.x;

        tries++;
    }while(!isReachable() && tries<20);

    ui.innerText=`关卡 ${level}`;
}

function reset(){
    player.x=100;player.y=300;
    player.vx=player.vy=0;
    gen();
}

/* 更新 */
function update(){
    player.vx=0;
    if(keys.ArrowLeft)player.vx=-player.speed;
    if(keys.ArrowRight)player.vx=player.speed;
    if((keys[" "]||keys.ArrowUp)&&player.onGround){
        player.vy=player.jump;player.onGround=false;
    }

    player.vy+=0.8;
    player.x+=player.vx;player.y+=player.vy;
    player.onGround=false;

    blink.forEach(b=>b.t=(b.t+1)%120);

    [...platforms,...moving,...blink.filter(b=>b.t<60)]
        .forEach(p=>resolve(player,p));

    moving.forEach(p=>{
        p.t+=p.sp;p.x=p.sx+Math.sin(p.t)*p.d;
    });

    if(!finished && player.x+player.w>=finishLineX){
        finished=true;level++;reset();
    }

    if(player.y>c.height)reset();
    if(player.x>c.width/2)camera=player.x-c.width/2;
}

/* 渲染 */
function draw(){
    ctx.clearRect(0,0,800,400);

    platforms.forEach(p=>{
        ctx.fillStyle=p.finish?"#f1c40f":"#2ecc71";
        ctx.fillRect(p.x-camera,p.y,p.w,p.h);
    });

    fake.forEach(p=>{
        ctx.fillStyle="rgba(200,200,200,0.4)";
        ctx.fillRect(p.x-camera,p.y,p.w,p.h);
    });

    ctx.fillStyle="#e74c3c";
    ctx.fillRect(player.x-camera,player.y,player.w,player.h);
}

function loop(){update();draw();requestAnimationFrame(loop);}
reset();loop();
</script>
</body>
</html>
