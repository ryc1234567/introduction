<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>方块跑酷 · 纯净单机版</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body{
    margin:0;background:#2c3e50;
    display:flex;justify-content:center;align-items:center;
    height:100vh;font-family:Arial;
}
#game{
    width:800px;height:400px;
    position:relative;border:2px solid #ecf0f1
}
canvas{background:#1a1a2e}
#ui{position:absolute;top:5px;left:10px;color:white}
</style>
</head>

<body>
<div id="game">
<canvas id="c" width="800" height="400"></canvas>
<div id="ui"></div>
</div>

<script>
const c=document.getElementById("c");
const ctx=c.getContext("2d");
const ui=document.getElementById("ui");
const keys={};

document.onkeydown=e=>keys[e.key]=true;
document.onkeyup=e=>keys[e.key]=false;

/* ===== 玩家 ===== */
const player={
    x:100,y:300,w:30,h:30,
    vx:0,vy:0,
    speed:5,jump:-15,
    onGround:false
};

let level=1,camera=0,length=1200;
let platforms=[],moving=[],invisible=[],fake=[],gravity=[],spikes=[],blink=[];

/* ===== 碰撞 ===== */
function resolve(a,b){
    const dx=(a.x+a.w/2)-(b.x+b.w/2);
    const dy=(a.y+a.h/2)-(b.y+b.h/2);
    const ox=(a.w+b.w)/2-Math.abs(dx);
    const oy=(a.h+b.h)/2-Math.abs(dy);
    if(ox>0&&oy>0){
        if(ox<oy){
            a.x+=dx>0?ox:-ox;
            a.vx=0;
        }else{
            a.y+=dy>0?oy:-oy;
            a.vy=0;
            if(dy<0)a.onGround=true;
        }
    }
}

function hit(a,b){
    return a.x<b.x+b.w&&a.x+a.w>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y;
}

/* ===== 生成关卡（含终点可达保证） ===== */
function gen(){
    platforms=[];moving=[];invisible=[];fake=[];
    gravity=[];spikes=[];blink=[];
    camera=0;

    const chap=Math.floor((level-1)/5)+1;
    const boss=level%5===0;
    length=boss?2200:1200+chap*250;

    platforms.push({x:0,y:350,w:200,h:50});

    let x=250,last=null;
    while(x<length-400){
        last={x,y:260+Math.sin(x*0.015)*60,w:90,h:20};
        platforms.push(last);
        x+=180+Math.random()*60;
    }

    // 终点平台（保证 ≤ 2/3 跳跃距离）
    const endX=(last?last.x:200)+150;
    platforms.push({x:endX,y:350,w:200,h:50});

    if(chap>=2){
        moving.push({x:600,y:200,sx:600,d:120,t:0,sp:0.02,w:80,h:20});
    }
    if(chap>=3){
        invisible.push({x:800,y:180,w:100,h:20});
    }
    if(chap>=4){
        fake.push({x:700,y:240,w:80,h:20});
    }
    if(chap>=5){
        blink.push({x:900,y:200,w:80,h:20,t:0});
        spikes.push({x:900,y:320,w:80,h:30});
    }

    ui.innerText=`关卡 ${level}${boss?" · BOSS":""}`;
}

/* ===== 重置 ===== */
function reset(){
    player.x=100;player.y=300;
    player.vx=0;player.vy=0;
    gen();
}

/* ===== 更新 ===== */
function update(){
    let g=0.8;
    player.vx=0;

    if(keys.ArrowLeft)player.vx=-player.speed;
    if(keys.ArrowRight)player.vx=player.speed;
    if((keys.ArrowUp||keys[" "])&&player.onGround){
        player.vy=player.jump;
        player.onGround=false;
    }

    player.vy+=g;
    player.x+=player.vx;
    player.y+=player.vy;
    player.onGround=false;

    blink.forEach(b=>b.t=(b.t+1)%120);

    const solids=[
        ...platforms,
        ...moving,
        ...invisible,
        ...blink.filter(b=>b.t<60)
    ];
    solids.forEach(p=>resolve(player,p));

    moving.forEach(p=>{
        p.t+=p.sp;
        p.x=p.sx+Math.sin(p.t)*p.d;
    });

    spikes.forEach(s=>{
        if(hit(player,s))reset();
    });

    if(player.y>c.height)reset();
    if(player.x>length){level++;reset();}
    if(player.x>c.width/2)camera=player.x-c.width/2;
}

/* ===== 渲染 ===== */
function draw(){
    ctx.clearRect(0,0,800,400);

    platforms.forEach(p=>{
        ctx.fillStyle="#2ecc71";
        ctx.fillRect(p.x-camera,p.y,p.w,p.h);
    });
    moving.forEach(p=>{
        ctx.fillStyle="#e67e22";
        ctx.fillRect(p.x-camera,p.y,p.w,p.h);
    });
    fake.forEach(p=>{
        ctx.strokeStyle="#aaa";
        ctx.strokeRect(p.x-camera,p.y,p.w,p.h);
    });
    blink.forEach(b=>{
        if(b.t<60){
            ctx.fillStyle="#3498db";
            ctx.fillRect(b.x-camera,b.y,b.w,b.h);
        }
    });
    spikes.forEach(s=>{
        ctx.fillStyle="#c0392b";
        ctx.fillRect(s.x-camera,s.y,s.w,s.h);
    });

    ctx.fillStyle="#e74c3c";
    ctx.fillRect(player.x-camera,player.y,player.w,player.h);
}

function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
}

reset();
loop();
</script>
</body>
</html>
