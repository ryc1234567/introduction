<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>å¼¹ç¬”æ¸¸æˆï¼ˆå°æ¡Œé¢ï¼‰</title>
<style>
body{
    margin:0;
    background:#eee;
    font-family:sans-serif;
    text-align:center;
}
button{
    font-size:18px;
    padding:10px 25px;
    margin:10px;
    cursor:pointer;
}
#menu{
    margin-top:120px;
}
#info{
    font-size:16px;
    margin:10px;
}
#wrap{
    display:none;
    position:relative;
    width:490px;
    margin:auto;
}
#game{
    width:490px;
    height:420px;
    border:8px solid #7b4a12;
    background:#caa46a;
}
#aim{
    position:absolute;
    left:0;
    top:0;
    pointer-events:none;
}
canvas{display:block;}
</style>
</head>
<body>

<div id="menu">
    <h1>âœï¸ å¼¹ç¬”æ¸¸æˆ</h1>
    <button onclick="startGame('pvp')">ğŸ® åŒäººå¯¹æˆ˜</button><br>
    <button onclick="startGame('ai')">ğŸ¤– äººæœºå¯¹æˆ˜</button>
</div>

<div id="info"></div>

<div id="wrap">
    <div id="game"></div>
    <canvas id="aim" width="490" height="420"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<script>
const {Engine,Render,Runner,World,Bodies,Body,Events} = Matter;

/* ===== å°ºå¯¸ï¼ˆæŒ‰ç¬”æ¯”ä¾‹ï¼‰ ===== */
const PEN_LENGTH = 70;
const WIDTH  = PEN_LENGTH * 7; // 490
const HEIGHT = PEN_LENGTH * 6; // 420

/* ===== ç‰©ç†å‚æ•° ===== */
const FORCE_PER_PIXEL = 0.00035; // å°æ¡Œé¢é€‚é…åç•¥å¢
const MAX_FORCE = 0.02;
const ROTATION_FACTOR = 0.004;
const STOP_SPEED = 0.12;

/* ===== å…¨å±€çŠ¶æ€ ===== */
let mode="pvp";
let engine, runner, render;
let pens=[], sensors=[];
let currentPlayer=1;
let waiting=false;
const info=document.getElementById("info");

/* ===== å¯åŠ¨ ===== */
function startGame(m){
    mode=m;
    document.getElementById("menu").style.display="none";
    document.getElementById("wrap").style.display="block";
    info.textContent="å½“å‰å›åˆï¼šç©å®¶ 1ï¼ˆè“è‰²ï¼‰";
    init();
}

function init(){
    engine=Engine.create();
    engine.gravity.y=0;

    render=Render.create({
        element:document.getElementById("game"),
        engine,
        options:{
            width:WIDTH,
            height:HEIGHT,
            wireframes:false,
            background:"#caa46a"
        }
    });
    Render.run(render);

    runner=Runner.create();
    Runner.run(runner,engine);

    /* ===== æ‰è½ä¼ æ„Ÿå™¨ï¼ˆæ— åå¼¹ï¼‰ ===== */
    sensors=[
        Bodies.rectangle(WIDTH/2,-80,WIDTH*2,160,{isStatic:true,isSensor:true}),
        Bodies.rectangle(WIDTH/2,HEIGHT+80,WIDTH*2,160,{isStatic:true,isSensor:true}),
        Bodies.rectangle(-80,HEIGHT/2,160,HEIGHT*2,{isStatic:true,isSensor:true}),
        Bodies.rectangle(WIDTH+80,HEIGHT/2,160,HEIGHT*2,{isStatic:true,isSensor:true})
    ];

    function pen(x,y,color,player){
        const p=Bodies.rectangle(x,y,PEN_LENGTH,5,{
            friction:0.6,
            frictionAir:0.08,
            restitution:0.2,
            render:{fillStyle:color}
        });
        p.player=player;
        return p;
    }

    /* ===== åˆå§‹å¸ƒå±€ï¼ˆå°æ¡Œé¢ï¼‰ ===== */
    pens=[
        pen(WIDTH*0.25,HEIGHT*0.35,"#2b7cff",1),
        pen(WIDTH*0.25,HEIGHT*0.65,"#2b7cff",1),
        pen(WIDTH*0.75,HEIGHT*0.35,"#ff4b4b",2),
        pen(WIDTH*0.75,HEIGHT*0.65,"#ff4b4b",2)
    ];

    World.add(engine.world,[...sensors,...pens]);

    setupInput();
    setupTurns();
    setupWin();
}

/* ===== è¾“å…¥ä¸æ‹‰çº¿ ===== */
function setupInput(){
    const aim=document.getElementById("aim");
    const ctx=aim.getContext("2d");
    let selected=null,sx=0,sy=0;

    render.canvas.onmousedown=e=>{
        if(waiting) return;
        if(mode==="ai" && currentPlayer===2) return;

        const r=render.canvas.getBoundingClientRect();
        sx=e.clientX-r.left;
        sy=e.clientY-r.top;

        selected=pens.find(p=>
            p.player===currentPlayer &&
            Matter.Bounds.contains(p.bounds,{x:sx,y:sy})
        );
    };

    render.canvas.onmousemove=e=>{
        if(!selected) return;
        const r=render.canvas.getBoundingClientRect();
        const cx=e.clientX-r.left, cy=e.clientY-r.top;
        ctx.clearRect(0,0,WIDTH,HEIGHT);
        ctx.beginPath();
        ctx.moveTo(sx,sy);
        ctx.quadraticCurveTo((sx+cx)/2,(sy+cy)/2-25,cx,cy);
        ctx.setLineDash([6,6]);
        ctx.stroke();
    };

    render.canvas.onmouseup=e=>{
        if(!selected) return;
        const r=render.canvas.getBoundingClientRect();
        shoot(selected,sx,sy,e.clientX-r.left,e.clientY-r.top);
        selected=null;
        ctx.clearRect(0,0,WIDTH,HEIGHT);
    };
}

/* ===== å‘å°„ ===== */
function shoot(p,sx,sy,ex,ey){
    const dx=sx-ex, dy=sy-ey;
    let fx=dx*FORCE_PER_PIXEL;
    let fy=dy*FORCE_PER_PIXEL;
    fx=Math.max(-MAX_FORCE,Math.min(MAX_FORCE,fx));
    fy=Math.max(-MAX_FORCE,Math.min(MAX_FORCE,fy));
    Body.applyForce(p,p.position,{x:fx,y:fy});
    Body.setAngularVelocity(p,(ex-p.position.x)*ROTATION_FACTOR);
    waiting=true;
}

/* ===== å›åˆç³»ç»Ÿ ===== */
function setupTurns(){
    Events.on(engine,"afterUpdate",()=>{
        if(!waiting) return;
        const moving=pens.some(p=>Math.hypot(p.velocity.x,p.velocity.y)>STOP_SPEED);
        if(!moving){
            waiting=false;
            currentPlayer=currentPlayer===1?2:1;
            info.textContent=`å½“å‰å›åˆï¼š${
                currentPlayer===1?"ç©å®¶ 1ï¼ˆè“è‰²ï¼‰":
                (mode==="ai"?"AIï¼ˆçº¢è‰²ï¼‰":"ç©å®¶ 2ï¼ˆçº¢è‰²ï¼‰")
            }`;
            if(mode==="ai" && currentPlayer===2){
                setTimeout(aiMove,500);
            }
        }
    });
}

/* ===== AI ===== */
function aiMove(){
    const aiPens=pens.filter(p=>p.player===2);
    const targets=pens.filter(p=>p.player===1);
    const p=aiPens[Math.floor(Math.random()*aiPens.length)];
    const t=targets[Math.floor(Math.random()*targets.length)];
    const ex=p.position.x+(p.position.x-t.position.x)*0.6+(Math.random()-0.5)*30;
    const ey=p.position.y+(p.position.y-t.position.y)*0.6+(Math.random()-0.5)*30;
    shoot(p,p.position.x,p.position.y,ex,ey);
}

/* ===== èƒœè´Ÿ ===== */
function setupWin(){
    let over=false;
    Events.on(engine,"collisionStart",e=>{
        if(over) return;
        e.pairs.forEach(pair=>{
            sensors.forEach(s=>{
                const p=pair.bodyA===s?pair.bodyB:pair.bodyB===s?pair.bodyA:null;
                if(p && pens.includes(p)){
                    over=true;
                    const w=p.player===1?2:1;
                    setTimeout(()=>{
                        alert(`ğŸ‰ ${w===1?"ç©å®¶ 1":"ç©å®¶ 2 / AI"} è·èƒœï¼`);
                        location.reload();
                    },80);
                }
            });
        });
    });
}
</script>

</body>
</html>
